{"meta":{"title":"Oduesp","subtitle":null,"description":null,"author":"Oduesp","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于","date":"2019-04-25T08:49:19.000Z","updated":"2019-04-25T09:53:15.167Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"分类","date":"2019-04-25T06:00:08.000Z","updated":"2019-04-26T04:09:12.026Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"标签","date":"2018-10-06T04:39:04.000Z","updated":"2019-04-29T11:06:07.869Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"Konjak Record——2019.05.11","slug":"Algorithm0511","date":"2019-05-11T06:45:56.938Z","updated":"2019-05-11T06:59:36.812Z","comments":true,"path":"2019/05/11/Algorithm0511/","link":"","permalink":"http://yoursite.com/2019/05/11/Algorithm0511/","excerpt":"","text":"素数打表1、P1832 A+B Problem（再升级）R:这是一个完全背包问题，对我来说这题还是挺难的，在大神眼里我就是个垃圾。注意代码中的质数打表方法，挺有用的(古人云:暴力出奇迹，打表出省一，爆搜挂着机，骗分过样例)。 12345678910111213141516171819202122232425262728293031323334353637383940#include using namespace std;const int maxn = 1000 + 10;int visited[maxn], primes[maxn], len, N;long long dp[maxn];void get_primes(){ for (int i = 2; i < maxn; i++) { if (!visited[i]) { primes[len++] = i; for (int j = i * i; j < maxn; j += i) { visited[j] = true; } } }}inline int cnt(){ for (int i = 0; i < len; i++) { if (primes[i] > N) { return i - 1; } } return 0;}int main(){ cin >> N; get_primes(); int num = cnt(); dp[0] = 1; for (int i = 0; i =1的区别！对于每次询问，我们先假设答案为f[s]，但s>=(d[1]+1)*c[1]，即f[s]中包含了第一种硬币超过限制的情况。要减去这部分。 很明显，对于第一种硬币超过限制的情况，所用的第一种硬币数量>=d[1]+1。 容易发现，总和为s，第一种硬币至少d[1]+1的情况个数，等于总和为s-(d[1]+1)*c[1]，硬币个数没有限制的情况个数！ 因为总和为s，第一种硬币至少d[1]+1的情况个数中，那d[1]+1个硬币是固定的，是不会变的，对于情况个数是不会有影响的。 所以，我们将原先为f[s]的答案减去f[s-(d[1]+1)*c[1]]即可得出正确答案。 这只是一种硬币超过限制的解决办法。对于两种硬币超过限制我们也同样这么减去，但重复减去了一部分：那些两种硬币同时超过限制的情况。 因此我们要加回两种硬币同时超过限制的情况接着用位运算计算容斥原理的结果。*/int main(){ for (int i = 1; i { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Konjak Records","slug":"Konjak-Records","permalink":"http://yoursite.com/categories/Konjak-Records/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"},{"name":"质数打表","slug":"质数打表","permalink":"http://yoursite.com/tags/质数打表/"},{"name":"容斥原理","slug":"容斥原理","permalink":"http://yoursite.com/tags/容斥原理/"}]},{"title":"Konjak Record——2019.05.10","slug":"Algorithm0510","date":"2019-05-10T08:02:01.922Z","updated":"2019-05-11T06:45:24.366Z","comments":true,"path":"2019/05/10/Algorithm0510/","link":"","permalink":"http://yoursite.com/2019/05/10/Algorithm0510/","excerpt":"","text":"常规题1、P1336 最佳课题选择R:多重背包 123456789101112131415161718192021222324252627282930#include using namespace std;const int maxn = 205;struct Node { int A, B;} nodes[25];int N, M;long long dp[25][maxn];int main(){ cin >> N >> M; for (int i = 1; i > nodes[i].A >> nodes[i].B; } memset(dp, 0x3f, sizeof(dp)); //前i个课题选0篇的时间均为0 for (int i = 0; i people[i] >> l >> r; if (l != 0) add_edge(i, l), add_edge(l, i); if (r != 0) add_edge(i, r), add_edge(r, i); } for (int i = 1; i v; if (v == f) { continue; } sum = (w[v] + sum) % mod; sq = (w[v] * w[v] + sq) % mod; //求第一第二的权值 if (w[v] >= first) { second = first, first = w[v]; } else { if (w[v] > second) { second = w[v]; } } dfs(v, s, f); } //注意这里负数的解决方法 total_sum = ((sum * sum - sq + mod) % mod + total_sum) % mod; mx = max(mx, first * second); total_sum = (2 * w[s] * w[g] + total_sum) % mod; mx = max(w[s] * w[g], mx);}int main(){ ios::sync_with_stdio(0), cin.tie(0); cin >> N; for (int i = 1; i < N; i++) { int u, v; cin >> u >> v; add_edge(u, v), add_edge(v, u); } for (int i = 1; i > w[i]; } dfs(1, 0, 0); cout","categories":[{"name":"Konjak Records","slug":"Konjak-Records","permalink":"http://yoursite.com/categories/Konjak-Records/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"LCS->LIS","slug":"LCS-LIS","permalink":"http://yoursite.com/tags/LCS-LIS/"},{"name":"单调队列","slug":"单调队列","permalink":"http://yoursite.com/tags/单调队列/"}]},{"title":"Konjak Record——2019.05.09","slug":"Algorithm0509","date":"2019-05-09T13:39:58.443Z","updated":"2019-05-09T14:34:06.690Z","comments":true,"path":"2019/05/09/Algorithm0509/","link":"","permalink":"http://yoursite.com/2019/05/09/Algorithm0509/","excerpt":"","text":"常规题1、P1279 字串距离R:最大公共子序列的变形。 123456789101112131415161718192021222324252627282930#include using namespace std;char a[2005], b[2005];int d, dp[2005][2005], alen, blen;inline int Min(int n1, int n2){ return n1 > n2 ? n2 : n1;}inline int Abs(int n1, int n2){ return n1 > n2 ? n1 - n2 : n2 - n1;}int main(){ scanf(\"%s\", &a[1]), scanf(\"%s\", &b[1]), scanf(\"%d\", &d), alen = strlen(a + 1), blen = strlen(b + 1); for (int i = 1; i N >> K; for (int i = 1; i > f[i]; sum[i] = sum[i - 1] + f[i]; } memset(dp, 0x3f, sizeof(dp)); dp[0][0] = 0; for (int i = 1; i","categories":[{"name":"Konjak Records","slug":"Konjak-Records","permalink":"http://yoursite.com/categories/Konjak-Records/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"区间dp","slug":"区间dp","permalink":"http://yoursite.com/tags/区间dp/"},{"name":"表达式转换","slug":"表达式转换","permalink":"http://yoursite.com/tags/表达式转换/"},{"name":"状压dp","slug":"状压dp","permalink":"http://yoursite.com/tags/状压dp/"}]},{"title":"Konjak Record——2019.05.07","slug":"Algorithm0507","date":"2019-05-07T10:17:57.142Z","updated":"2019-05-09T13:39:42.212Z","comments":true,"path":"2019/05/07/Algorithm0507/","link":"","permalink":"http://yoursite.com/2019/05/07/Algorithm0507/","excerpt":"","text":"常规题1、P1216 [IOI1994][USACO1.5]数字三角形 Number TrianglesR:水题 12345678910111213141516171819202122232425262728#include using namespace std;const int maxn = 1005;int f[maxn][maxn], dp[maxn][maxn], N;int main(){ ios::sync_with_stdio(false); cin.tie(0); cin >> N; for (int i = 1; i f[i][j]; } if (i == N) { for (int j = 1; j = 1; i--) { for (int j = 1; j > M; for (int i = 1; i f[i][j]; L[i][j] = R[i][j] = j; up[i][j] = 1; } } //预处理L for (int i = 1; i a[i].s >> a[i].w >> a[i].fa, id[a[i].s] = i; for (int i = 1; i v; int t = dfs(v); sum += t; for (int i = sum; i >= 0; i--) { for (int j = 1; j = j) { dp[x][i] = max(dp[x][i], dp[v][j] + dp[x][i - j] - p->len); } } } } return sum;}int main(){ ios::sync_with_stdio(false); cin.tie(0); cin >> N >> M; for (int i = 1; i > K; for (int j = 1; j > a >> c; add_edge(i, a, c); du[c]++; } } for (int i = N - M + 1; i > pay[i]; } dfs(1); for (int j = M; j >= 0; j--) { if (dp[1][j] >= 0) { cout { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Konjak Records","slug":"Konjak-Records","permalink":"http://yoursite.com/categories/Konjak-Records/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"悬线法","slug":"悬线法","permalink":"http://yoursite.com/tags/悬线法/"},{"name":"Dilworth定理","slug":"Dilworth定理","permalink":"http://yoursite.com/tags/Dilworth定理/"},{"name":"树形dp","slug":"树形dp","permalink":"http://yoursite.com/tags/树形dp/"}]},{"title":"Konjak Record——2019.05.06","slug":"Algorithm0506","date":"2019-05-06T10:32:45.766Z","updated":"2019-05-06T10:51:42.086Z","comments":true,"path":"2019/05/06/Algorithm0506/","link":"","permalink":"http://yoursite.com/2019/05/06/Algorithm0506/","excerpt":"","text":"常规题1、P1057 传球游戏R:水题，思路很好想。 123456789101112131415161718192021222324252627#include using namespace std;int dp[35][35], N, M;int main(){ cin >> N >> M; dp[1][0] = 1; for (int i = 1; i > M; for (int i = 1; i > f[i]; } dp[0] = 1; for (int i = 1; i = 0; j--) { for (int k = 1; k = 0; k++) { dp[j] = (dp[j - k] + dp[j]) % mod; } } } cout N; for (int i = 1; i > f[i]; } for (int i = 1; i > M; for (int i = 1; i chess[i][j]; } } for (int i = 1; i > K; for (int i = 1; i > nodes[i].h >> nodes[i].w; } sort(nodes + 1, nodes + 1 + N, cmp); memset(dp, 0x3f, sizeof(dp)); dp[0][0] = 0; for (int i = 1; i j - (i - k - 1) && j - (i - k - 1) >= 0) { dp[i][j] = Min(dp[i][j], dp[k][j - (i - k - 1)] + Abs(nodes[i].w - nodes[k].w)); } } } } for (int i = 1; i = 0) { ans = min(dp[i][K - (N - i)], ans); } } cout N; for (int i = 1; i > f[i]; } //O(N^2)，N小于等于5000没问题 for (int i = 1; i","categories":[{"name":"Konjak Records","slug":"Konjak-Records","permalink":"http://yoursite.com/categories/Konjak-Records/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}]},{"title":"Konjak Record——2019.05.02","slug":"Algorithm0502","date":"2019-05-02T04:01:40.078Z","updated":"2019-05-02T13:12:31.019Z","comments":true,"path":"2019/05/02/Algorithm0502/","link":"","permalink":"http://yoursite.com/2019/05/02/Algorithm0502/","excerpt":"","text":"模板题P3834 【模板】可持久化线段树 1（主席树）R:求区间第k大，主席树方法，注意离散化的方法，以及二分查找。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include using namespace std;const int maxn = 2e5 + 10;int root[maxn], N, Q, f[maxn], cnt;struct Node { int l, r, sum;};Node T[maxn * 40];vector v;inline int getid(int x){ return lower_bound(v.begin(), v.end(), x) - v.begin() + 1;}inline int read(){ int f = 1, r = 0; char c = getchar(); while (!isdigit(c)) { if (c == '-') f = -1; c = getchar(); } while (isdigit(c)) { r = 10 * r + c - '0'; c = getchar(); } return f * r;}void update(int pos, int l, int r, int& x, int y){ T[++cnt] = T[y], x = cnt; T[cnt].sum += 1; if (l == r) { return; } int mid = (l + r) >> 1; if (pos > 1; if (sum >= k) { return query(l, mid, T[x].l, T[y].l, k); } else { return query(mid + 1, r, T[x].r, T[y].r, k - sum); }}int main(){ N = read(), Q = read(); for (int i = 1; i > k; update(x, y, 1, N, k, 1); } else { long long q = query(x, y, 1, N, 1); cout T[x].v; return; } int mid = (l + r) >> 1; build(l, mid, T[x].l); build(mid + 1, r, T[x].r);}void update(int pos, int v, int l, int r, int& x, int y){ T[++cnt] = T[y], x = cnt; if (l == r) { T[x].v = v; return; } int mid = (l + r) >> 1; if (pos > 1; if (pos > N >> M; build(1, N, root[0]); for (int i = 1; i > v >> w >> loc; if (w == 1) { cin >> u; update(loc, u, 1, N, root[i], root[v]); } else { root[i] = root[v]; int q = query(loc, 1, N, root[i]); cout = L && r > 1; int mn = 0x3f3f3f3f; if (mid >= L) { mn = min(query(L, R, l, mid, T[cur].l), mn); } if (mid < R) { mn = min(query(L, R, mid + 1, r, T[cur].r), mn); } return mn;}int main(){ scanf(\"%d %d\", &N, &M); build(1, N, root); for (int i = 1; i { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Konjak Records","slug":"Konjak-Records","permalink":"http://yoursite.com/categories/Konjak-Records/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/线段树/"},{"name":"主席树","slug":"主席树","permalink":"http://yoursite.com/tags/主席树/"}]},{"title":"Konjak Record——2019.05.01","slug":"Algorithm0501","date":"2019-05-01T02:52:51.729Z","updated":"2019-05-01T11:13:20.105Z","comments":true,"path":"2019/05/01/Algorithm0501/","link":"","permalink":"http://yoursite.com/2019/05/01/Algorithm0501/","excerpt":"常规题1、P1177 【模板】快速排序分析：要求写快速排序，我很懒，就直接调用了sort函数(其实是不会)。 12345678910111213141516#include using namespace std;const int maxn = 100000+10;int f[maxn],N;int main(){ scanf(\"%d\",&N); for(int i = 1 ; i","text":"常规题1、P1177 【模板】快速排序分析：要求写快速排序，我很懒，就直接调用了sort函数(其实是不会)。 12345678910111213141516#include using namespace std;const int maxn = 100000+10;int f[maxn],N;int main(){ scanf(\"%d\",&N); for(int i = 1 ; i K; for(int i = 1 ; i >E[i]; } for(int i = 1 ; i>nodes[i].w; nodes[i].id=i; } sort(nodes+1,nodes+1+N,cmp); for(int i = 1 ; i >shitLeader>>w>>shitSci; int tmp = 0; if(self>80&&shitSci>=1){ tmp+=8000; } if(self>85&&shits>80){ tmp+=4000; } if(self>90){ tmp+=2000; } if(w=='Y'&&self>85){ tmp+=1000; } if(shitLeader=='Y'&&shits > 80){ tmp+=850; } if(tmp>sm){ sm=tmp,mx=name; } total += tmp; } cout","categories":[{"name":"Konjak Records","slug":"Konjak-Records","permalink":"http://yoursite.com/categories/Konjak-Records/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"}]},{"title":"Konjak Record——2019.04.30","slug":"Algorithm0430","date":"2019-04-30T06:29:16.296Z","updated":"2019-04-30T12:52:19.220Z","comments":true,"path":"2019/04/30/Algorithm0430/","link":"","permalink":"http://yoursite.com/2019/04/30/Algorithm0430/","excerpt":"常规题1、P1855 榨取kkksc03分析：01背包的变形，多加一个维度就可以了 123456789101112131415161718192021#include using namespace std;const int maxn = 105, maxm = 205;int dp[maxm][maxm], m[maxm], t[maxm], N, M, T;int main(){ scanf(\"%d %d %d\", &N, &M, &T); for (int i = 1; i = t[i]; k--) { dp[j][k] = max(dp[j][k], dp[j - m[i]][k - t[i]] + 1); } } } printf(\"%d\\n\", dp[M][T]); system(\"pause\"); return 0;}","text":"常规题1、P1855 榨取kkksc03分析：01背包的变形，多加一个维度就可以了 123456789101112131415161718192021#include using namespace std;const int maxn = 105, maxm = 205;int dp[maxm][maxm], m[maxm], t[maxm], N, M, T;int main(){ scanf(\"%d %d %d\", &N, &M, &T); for (int i = 1; i = t[i]; k--) { dp[j][k] = max(dp[j][k], dp[j - m[i]][k - t[i]] + 1); } } } printf(\"%d\\n\", dp[M][T]); system(\"pause\"); return 0;} 错题2、P1736 创意吃鱼法分析：这个题调试了一个下午才AC，还是太菜了。使用的是悬线法,注意对角线共两个方向，此外必须保证除了对角线为1以外其他都为0。具体细节见代码。代码跑的很慢，复杂度是O(N2),而且我是大常数男人。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include using namespace std;const int maxn = 2505;int N, M;short chess[maxn][maxn], l[maxn][maxn], L[maxn][maxn];short r[maxn][maxn], R[maxn][maxn], u[maxn][maxn], U[maxn][maxn], f[maxn][maxn], ans;int main(){ scanf(\"%d %d\", &N, &M); memset(chess, -1, sizeof(chess)); for (int i = 1; i chess[i][j]; l[i][j] = j, r[i][j] = j, u[i][j] = i; L[i][j] = R[i][j] = j, U[i][j] = i; } } for (int i = 1; i > G; for (int i = 1; i > nodes[i].t >> nodes[i].f >> nodes[i].h; } sort(nodes + 1, nodes + 1 + G, cmp); memset(dp, -1, sizeof(dp)); dp[0][0] = 10; for (int i = 1; i = D) { printf(\"%d\\n\", nodes[i].t); system(\"pause\"); return 0; } if (dp[i - 1][j] >= pay) { dp[i][j] = dp[i - 1][j] - pay + nodes[i].f; } if (j >= nodes[i].h && dp[i - 1][j - nodes[i].h] >= pay) { dp[i][j] = max(dp[i][j], dp[i - 1][j - nodes[i].h] - pay); } } } int maxt = 0; for (int i = 0; i { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Konjak Records","slug":"Konjak-Records","permalink":"http://yoursite.com/categories/Konjak-Records/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}]},{"title":"Konjak Record——2019.04.29","slug":"Algorithm0429","date":"2019-04-29T06:38:36.135Z","updated":"2019-04-29T11:27:18.615Z","comments":true,"path":"2019/04/29/Algorithm0429/","link":"","permalink":"http://yoursite.com/2019/04/29/Algorithm0429/","excerpt":"常规题1、P1140 相似基因分析：LCS的变形，水题","text":"常规题1、P1140 相似基因分析：LCS的变形，水题 2、P1282 多米诺骨牌分析：背包的变形，记录上下差值为M时的最小翻转次数，因为有正负，所以多开一维表达正负数。 123sub = up[i] - down[i]dp[i][j] = min(dp[i - 1][j - sub],dp[i - 1][j + sub] + 1)-maxm < j < maxm,1 nodes[i].b; } for (int i = 1; i > nodes[i].t; } sort(nodes + 1, nodes + 1 + N, cmp); for (ll i = 1; i = nodes[i].t; j--) { dp[j] = max(dp[j - nodes[i].t] + nodes[i].a - nodes[i].b * j, dp[j]); } } long long ans = -1; for (ll i = 1; i { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Konjak Records","slug":"Konjak-Records","permalink":"http://yoursite.com/categories/Konjak-Records/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}]},{"title":"Chtholly Nota Seniorious","slug":"Chtholly Nota Seniorious","date":"2019-04-26T05:29:26.974Z","updated":"2019-04-26T07:21:56.264Z","comments":true,"path":"2019/04/26/Chtholly Nota Seniorious/","link":"","permalink":"http://yoursite.com/2019/04/26/Chtholly Nota Seniorious/","excerpt":"C++1cout","text":"C++1cout { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"科学","slug":"科学","permalink":"http://yoursite.com/categories/科学/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-04-25T03:08:59.435Z","updated":"2019-04-26T04:29:16.111Z","comments":true,"path":"2019/04/25/hello-world/","link":"","permalink":"http://yoursite.com/2019/04/25/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]}]}