{"meta":{"title":"Oduesp","subtitle":null,"description":null,"author":"Oduesp","url":"http://yoursite.com","root":"/"},"pages":[{"title":"标签","date":"2018-10-06T04:39:04.000Z","updated":"2019-04-29T11:06:07.869Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"关于","date":"2019-04-25T08:49:19.000Z","updated":"2019-04-25T09:53:15.167Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"分类","date":"2019-04-25T06:00:08.000Z","updated":"2019-04-26T04:09:12.026Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"Konjak Record——2019.05.29","slug":"Algorithm0529","date":"2019-05-29T14:09:24.747Z","updated":"2019-05-29T14:30:05.576Z","comments":true,"path":"2019/05/29/Algorithm0529/","link":"","permalink":"http://yoursite.com/2019/05/29/Algorithm0529/","excerpt":"","text":"P3558 [POI2013]BAJ-BytecomputerR：f[i][0]表示第i个数以-1结尾的最小修正次数，f[i][1],f[i][2]类似,然后分类讨论a[i]的情况 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include const int maxn = 1000000 + 5;int f[maxn][3], arr[maxn], N;inline int read(){ int f = 1, r = 0; char c = getchar(); while (!isdigit(c)) { if (c == '-') f = -1; c = getchar(); } while (isdigit(c)) { r = 10 * r + c - '0'; c = getchar(); } return f * r;}inline int min(int a, int b) { return a < b ? a : b; }int main(){ N = read(); for (int i = 1; i =g[j]的最大j) * 证明：i+1，f[i+1]比f[i]最多+1，但是i-1-j时却是实实在在的多一个1 * 令h[j] = sum[j] + g[j]，维护一个单调增加队列 * 如果新来一个h[j]>=尾部，则直接添加，反之删除尾部，不用担心删除合理的解，因为如果它能删除 * 说明它更合理，因为j更大而且h[j]更小，后续sum是单增的。 * 注意需要删除头部过期数据，因为需要找一个满足条件且j更靠后的。 * **/signed main(){ scanf(\"%lld\", &N); for (int i = 1; i","categories":[{"name":"Konjak Records","slug":"Konjak-Records","permalink":"http://yoursite.com/categories/Konjak-Records/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/线段树/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"区间dp","slug":"区间dp","permalink":"http://yoursite.com/tags/区间dp/"},{"name":"单调队列","slug":"单调队列","permalink":"http://yoursite.com/tags/单调队列/"},{"name":"重要","slug":"重要","permalink":"http://yoursite.com/tags/重要/"},{"name":"省选","slug":"省选","permalink":"http://yoursite.com/tags/省选/"},{"name":"数位dp","slug":"数位dp","permalink":"http://yoursite.com/tags/数位dp/"}]},{"title":"Konjak Record——2019.05.27","slug":"Algorithm0527","date":"2019-05-27T10:46:17.620Z","updated":"2019-05-27T11:20:54.628Z","comments":true,"path":"2019/05/27/Algorithm0527/","link":"","permalink":"http://yoursite.com/2019/05/27/Algorithm0527/","excerpt":"","text":"P2744 [USACO5.3]量取牛奶Milk MeasuringR:使用dfs枚举桶，dp完全背包判断合理性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include #define ri register int/** * 迭代加深搜索id-dfs,从少到多枚举水桶数量、从小到大枚举水桶容积，第一次遇到的解一定是最优解 * 判断合理性用完全背包 * 编码难度不高，思路也很好想，但是这个复杂度上限非常高，所以我没想到这样也能AC * **/int Q, P, V[105], cache[105], visited[105], depth, flag, f[20005];int check(){ memset(f, 0, sizeof(f)); f[0] = 1; for (ri i = 1; i","categories":[{"name":"Konjak Records","slug":"Konjak-Records","permalink":"http://yoursite.com/categories/Konjak-Records/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"状压dp","slug":"状压dp","permalink":"http://yoursite.com/tags/状压dp/"},{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"},{"name":"树形dp","slug":"树形dp","permalink":"http://yoursite.com/tags/树形dp/"},{"name":"补集","slug":"补集","permalink":"http://yoursite.com/tags/补集/"},{"name":"分组dp","slug":"分组dp","permalink":"http://yoursite.com/tags/分组dp/"},{"name":"思维","slug":"思维","permalink":"http://yoursite.com/tags/思维/"},{"name":"多重背包","slug":"多重背包","permalink":"http://yoursite.com/tags/多重背包/"},{"name":"完全背包","slug":"完全背包","permalink":"http://yoursite.com/tags/完全背包/"},{"name":"01背包","slug":"01背包","permalink":"http://yoursite.com/tags/01背包/"},{"name":"逆序对","slug":"逆序对","permalink":"http://yoursite.com/tags/逆序对/"}]},{"title":"Konjak Record——2019.05.24","slug":"Algorithm0524","date":"2019-05-24T11:49:09.999Z","updated":"2019-05-24T12:35:29.377Z","comments":true,"path":"2019/05/24/Algorithm0524/","link":"","permalink":"http://yoursite.com/2019/05/24/Algorithm0524/","excerpt":"","text":"P3957 跳房子R:二分答案+单调队列优化dp,是很好很好的题目。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include using namespace std;const int maxn = 500000 + 10, inf = 0x3f3f3f3f;/** * 二分答案+dp+单调队列 * 首先如果花费g个金币能过，那么g+1个金币肯定也能过 * 其次，f[i] = max(f[k]),f[k]具有范围，可以用单调队列维护，这样就可以有O(N)的复杂度 * 由于有效范围是[x-r,x-l]，所以不能每来一个数据就直接把它加进单调队列，需要首先判断它的范围 * 然后剔除垃圾数据，最后取队头，看看存不存在 * **/int N, D, K, dis[maxn], score[maxn], f[maxn], h, t, Q[maxn];int check(int g){ f[0] = 0; int j = 0; int mn = max(D - g, 1); h = 1, t = 0; for (int i = 1; i = mn; j++) { //无法到达的不选 if (f[j] == -inf) { continue; } while (h v] || in[p->v][0]) continue; Q[++tail] = p->v; inq[p->v] = 1; } }}void bfs_n(){ memset(inq, 0, sizeof(inq)); head = 1, tail = 0; Q[++tail] = N, inq[N] = 1, dp[N][1] = 1; while (head next) { dp[p->v][1] += dp[top][1]; in[p->v][1]--; if (inq[p->v] || in[p->v][1]) continue; Q[++tail] = p->v; inq[p->v] = 1; } }}int main(){ cin >> N >> M; for (int i = 1; i > u >> v; in[v][0]++, in[u][1]++; add_positive(u, v), add_negative(v, u); } bfs_p(); bfs_n(); for (int i = 1; i next) { int u = i, v = p->v; ans = max(ans, dp[u][0] * dp[v][1]); } } cout > N >> T; for (int i = 1; i > V[i]; mx = max(V[i] * V[i], mx); } for (int i = 1; i > C[i]; } memset(f, 0x3f, sizeof(f)), memset(g, 0x3f, sizeof(g)); f[0] = g[0] = 0; //跑一编完全背包 for (int i = 1; i","categories":[{"name":"Konjak Records","slug":"Konjak-Records","permalink":"http://yoursite.com/categories/Konjak-Records/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"状压dp","slug":"状压dp","permalink":"http://yoursite.com/tags/状压dp/"},{"name":"迪杰斯特拉算法","slug":"迪杰斯特拉算法","permalink":"http://yoursite.com/tags/迪杰斯特拉算法/"},{"name":"树形dp","slug":"树形dp","permalink":"http://yoursite.com/tags/树形dp/"},{"name":"单调队列","slug":"单调队列","permalink":"http://yoursite.com/tags/单调队列/"},{"name":"思维","slug":"思维","permalink":"http://yoursite.com/tags/思维/"},{"name":"多重背包","slug":"多重背包","permalink":"http://yoursite.com/tags/多重背包/"},{"name":"完全背包","slug":"完全背包","permalink":"http://yoursite.com/tags/完全背包/"},{"name":"01背包","slug":"01背包","permalink":"http://yoursite.com/tags/01背包/"},{"name":"二分答案","slug":"二分答案","permalink":"http://yoursite.com/tags/二分答案/"},{"name":"倍增","slug":"倍增","permalink":"http://yoursite.com/tags/倍增/"},{"name":"bfs树形dp","slug":"bfs树形dp","permalink":"http://yoursite.com/tags/bfs树形dp/"},{"name":"异或","slug":"异或","permalink":"http://yoursite.com/tags/异或/"}]},{"title":"Konjak Record——2019.05.23","slug":"Algorithm0523","date":"2019-05-23T07:45:20.748Z","updated":"2019-05-24T12:28:37.277Z","comments":true,"path":"2019/05/23/Algorithm0523/","link":"","permalink":"http://yoursite.com/2019/05/23/Algorithm0523/","excerpt":"","text":"P2530 [SHOI2001]化工厂装箱员R:挺难的一道动态规划题 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include using namespace std;/** * dp[i][j][k][l]表示前i个物品，手头有j个A,k个B,l个C的最小装箱数，当j+k+l>10时不处理 * 没新来一个物品，则可以由上一个状态转移（不装箱），装箱数不变 * 可以选择装箱，更新最小装箱数 * **/const int maxn = 105;int dp[maxn][15][15][15], N;char type[maxn];int main(){ cin >> N; for (int i = 1; i > type[i]; } memset(dp, 0x3f, sizeof(dp)); dp[0][0][0][0] = 0; for (int i = 1; i = 0; j--) { for (int k = 10; k >= 0; k--) { for (int l = 10; l >= 0; l--) { if (j + k + l > 10) { continue; } if (type[i] == 'A' && j + k + l 0) { dp[i][j][k][l] = dp[i - 1][j - 1][k][l]; } if (type[i] == 'B' && j + k + l 0) { dp[i][j][k][l] = dp[i - 1][j][k - 1][l]; } if (type[i] == 'C' && j + k + l 0) { dp[i][j][k][l] = dp[i - 1][j][k][l - 1]; } dp[i][0][k][l] = min(dp[i][0][k][l], dp[i][j][k][l] + 1); dp[i][j][0][l] = min(dp[i][j][0][l], dp[i][j][k][l] + 1); dp[i][j][k][0] = min(dp[i][j][k][0], dp[i][j][k][l] + 1); } } } } cout > K >> C; for (int i = 1; i > A[i]; } for (int i = 1; i > B[i]; } memset(f, ~0x3f, sizeof(f)); f[0][0] = 0; for (int i = 1; i > a >> b; w = B[a] + B[b]; for (int j = K; j >= 1; j--) { for (int k = 2004; k >= w; k--) { f[j][k] = max(f[j][k], f[j - 1][k - w] + A[a] * A[b]); } } } for (int i = 0; i tmp; q.push(tmp); } for (int i = 1; i tmp; arr[tmp] = arr[tmp + M] = q.top(); q.pop(); s += arr[tmp]; } q.push(s); for (int j = 1; j S[i]; } up = (1","categories":[{"name":"Konjak Records","slug":"Konjak-Records","permalink":"http://yoursite.com/categories/Konjak-Records/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"状压dp","slug":"状压dp","permalink":"http://yoursite.com/tags/状压dp/"},{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"},{"name":"树形dp","slug":"树形dp","permalink":"http://yoursite.com/tags/树形dp/"},{"name":"素数打表","slug":"素数打表","permalink":"http://yoursite.com/tags/素数打表/"},{"name":"背包前K优解","slug":"背包前K优解","permalink":"http://yoursite.com/tags/背包前K优解/"},{"name":"田忌赛马","slug":"田忌赛马","permalink":"http://yoursite.com/tags/田忌赛马/"},{"name":"归并排序","slug":"归并排序","permalink":"http://yoursite.com/tags/归并排序/"}]},{"title":"Konjak Record——2019.05.21","slug":"Algorithm0521","date":"2019-05-21T11:45:08.050Z","updated":"2019-05-21T14:19:12.576Z","comments":true,"path":"2019/05/21/Algorithm0521/","link":"","permalink":"http://yoursite.com/2019/05/21/Algorithm0521/","excerpt":"","text":"P2134 百日旅行R:斜率优化 12345678910111213141516171819202122232425262728293031323334#include using namespace std;/** * 这道题的转移方程很好想，很容易得到90分，还有10分需要使用单调队列才可以。 * **/#define ll long longconst int maxn = 200000 + 10;ll f[maxn], g[maxn], N, P, Q;int gq[maxn], gqh, gqt;ll minq;//gq存的是组成g下凸壳的index,gqh,gqt分别表示head,tail指针inline ll calcgq(int i, int j) { return g[j] + P * j * j - 2 * P * i * j + P * i * i; }inline double slope(int i, int j) { return 1.0 * (g[j] + P * j * j - g[i] - P * i * i) / (j - i); }int main(){ cin >> N >> P >> Q; memset(f, 0x3f, sizeof(f)), memset(g, 0x3f, sizeof(g)); f[0] = 0, g[0] = 0; //初始化队列 gq[1] = 0, gqh = 1, gqt = 1; for (int i = 1; i = calcgq(i, gq[gqh + 1])) gqh++; f[i] = calcgq(i, gq[gqh]); while (gqh < gqt && slope(gq[gqt - 1], gq[gqt]) >= slope(gq[gqt - 1], i)) gqt--; gq[++gqt] = i; minq = min(minq, f[i] - Q * i); } cout N >> K; for (int i = 1; i > tmp; sum[i] = sum[i - 1] + tmp; } avg = sum[N] * 1.0 / K; for (int i = 0; i K; for (int i = 1; i > tmp; sum[i] = sum[i - 1] + tmp.size(); } avg = sum[N] * 1.0 / K; for (int i = 0; i N >> T; for (int i = 1; i > S[i]; sum[i] = sum[i - 1] + S[i]; } for (int i = 1; i > B[i]; } memset(mx, ~0x3f, sizeof(mx)); mx[0] = 0; //mx[j]表示前i个，j步的最大值 for (int i = 1; i = 1; j--) { if (j == 1) { f[j] = max(remNum + S[i] - sum[i - 1], S[i] - sum[i - 1]); mx[j] = max(mx[j], f[j] + sum[i]); } else if (j == T) { f[j] = mx[j - 1] + S[i] + B[i] - sum[i - 1]; mx[j] = max(mx[j], f[j] + sum[i]); } else { f[j] = mx[j - 1] + S[i] - sum[i - 1]; mx[j] = max(mx[j], f[j] + sum[i]); } } } int ans = 0; for (int i = 1; i","categories":[{"name":"Konjak Records","slug":"Konjak-Records","permalink":"http://yoursite.com/categories/Konjak-Records/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"单调队列","slug":"单调队列","permalink":"http://yoursite.com/tags/单调队列/"},{"name":"斜率优化","slug":"斜率优化","permalink":"http://yoursite.com/tags/斜率优化/"},{"name":"滚动数组","slug":"滚动数组","permalink":"http://yoursite.com/tags/滚动数组/"}]},{"title":"Konjak Record——2019.05.20","slug":"Algorithm0520","date":"2019-05-20T11:08:56.812Z","updated":"2019-05-20T11:21:11.435Z","comments":true,"path":"2019/05/20/Algorithm0520/","link":"","permalink":"http://yoursite.com/2019/05/20/Algorithm0520/","excerpt":"","text":"P2921 [USACO08DEC]在农场万圣节Trick or Treat on the FarmR:dfs+回溯+dp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include using namespace std;/*** * 这道题仔细思考并不难，用的是dfs+记忆化搜索,如果一个点搜过，那么如果另一个搜索时遇到这个点 * 就直接加上这个点的答案即可 * 其中用到了引用用于回溯时的变量控制。 * **/const int maxn = 100000 + 10;int f[maxn], nxt[maxn], N, length[maxn], ans[maxn], in_circle[maxn];int dfs(int pos, int l, int& circle, int& overlap){ if (in_circle[pos] || ans[pos]) { overlap = pos; length[pos] = l; return ans[pos]; } if (length[pos] != 0) { ans[pos] = l - length[pos], overlap = pos, circle = 1, in_circle[pos] = 1; return l - length[pos]; } length[pos] = l; //递归 int cr = dfs(nxt[pos], l + 1, circle, overlap); //回溯 if (circle) { ans[pos] = cr, in_circle[pos] = 1; if (pos == overlap) { circle = 0; } return cr; } ans[pos] = cr + length[overlap] - length[pos]; return cr;}int main(){ scanf(\"%d\", &N); for (int i = 1; i v, r); sum += cur + 1; for (int i = sum; i >= 1; i--) { for (int j = 0; j v][j] + p->w); } } } } return sum;}int main(){ cin >> N >> Q; for (int i = 1; i < N; i++) { int u, v, w; cin >> u >> v >> w; add_edge(u, v, w), add_edge(v, u, w); } dfs(1, 0); cout","categories":[{"name":"Konjak Records","slug":"Konjak-Records","permalink":"http://yoursite.com/categories/Konjak-Records/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"dfs","slug":"dfs","permalink":"http://yoursite.com/tags/dfs/"},{"name":"树形dp","slug":"树形dp","permalink":"http://yoursite.com/tags/树形dp/"},{"name":"树形背包","slug":"树形背包","permalink":"http://yoursite.com/tags/树形背包/"}]},{"title":"Konjak Record——2019.05.19","slug":"Algorithm0519","date":"2019-05-19T06:16:02.245Z","updated":"2019-05-19T10:43:51.614Z","comments":true,"path":"2019/05/19/Algorithm0519/","link":"","permalink":"http://yoursite.com/2019/05/19/Algorithm0519/","excerpt":"","text":"P2258 子矩阵R:dfs+区间dp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include using namespace std;/*** * 枚举R行，复杂度为C(16,8)=12870 * dp是O(N^3) * **/const int maxn = 20;int ans = 0x3f3f3f3f;int N, M, chess[maxn][maxn], R, C, cache[maxn], vis[maxn], f[maxn][maxn], colsum[maxn], sub[maxn][maxn];void dfs(int s, int n){ if (n == R) { memset(f, 0x3f, sizeof(f)); f[0][0] = 0; memset(colsum, 0, sizeof(colsum)); memset(sub, 0, sizeof(sub)); //计算枚举的行中，每列的差的绝对值之和。 for (int j = 1; j N >> K; f[1][1] = 1, sum[1][1] = 1; for (int i = 1; i every >> startCost >> N; for (int i = 1; i > pos[i] >> spend[i]; } pos[N + 1] = dis; memset(f, 0x3f, sizeof(f)); f[0] = startCost * 100 + 0.5; for (int i = 1; i = 0; j--) { double dis = pos[i] - pos[j]; double consume = dis / every; if (consume > contain) { break; } if (consume >= contain / 2) { f[i] = min((int)(f[j] + 200 + consume * spend[i] + 0.5), f[i]); } } } int ans = 0x3f3f3f3f; for (int i = N; i >= 0; i--) { double dis = pos[N + 1] - pos[i]; double consume = dis / every; if (consume > contain) { break; } ans = min(ans, f[i]); } printf(\"%.2lf\\n\", ans * 1.0 / 100.0); system(\"pause\"); return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Konjak Records","slug":"Konjak-Records","permalink":"http://yoursite.com/categories/Konjak-Records/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"区间dp","slug":"区间dp","permalink":"http://yoursite.com/tags/区间dp/"},{"name":"dfs","slug":"dfs","permalink":"http://yoursite.com/tags/dfs/"},{"name":"加油问题","slug":"加油问题","permalink":"http://yoursite.com/tags/加油问题/"}]},{"title":"Konjak Record——2019.05.18","slug":"Algorithm0518","date":"2019-05-18T08:14:59.381Z","updated":"2019-05-19T06:16:19.158Z","comments":true,"path":"2019/05/18/Algorithm0518/","link":"","permalink":"http://yoursite.com/2019/05/18/Algorithm0518/","excerpt":"","text":"P1854 花店橱窗布置R:背包问题，动态规划中的路径记录 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include using namespace std;/** * f[i][j]表示前i盆花放在前j个盆的最大值 * f[i][j] = max(f[i-1][j],f[i-1][j-1]+收益) * 初始化f[0][0]=0,这道题的路径记录有点意思 * 我的空间复杂度是O(N^3)，但是这是一个从无到有的过程 * **/const int maxn = 100 + 10;int f[maxn][maxn], F, V, A[maxn][maxn];struct Node { int tail, a[maxn];} way[maxn][maxn];int main(){ memset(f, ~0x3f, sizeof(f)); cin >> F >> V; //第0棵花放到前V个花瓶的收益为0 for (int i = 0; i","categories":[{"name":"Konjak Records","slug":"Konjak-Records","permalink":"http://yoursite.com/categories/Konjak-Records/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"背包","slug":"背包","permalink":"http://yoursite.com/tags/背包/"},{"name":"路径记录","slug":"路径记录","permalink":"http://yoursite.com/tags/路径记录/"},{"name":"回文dp","slug":"回文dp","permalink":"http://yoursite.com/tags/回文dp/"}]},{"title":"Konjak Record——2019.05.17","slug":"Algorithm0517","date":"2019-05-17T04:44:09.505Z","updated":"2019-05-17T05:50:11.417Z","comments":true,"path":"2019/05/17/Algorithm0517/","link":"","permalink":"http://yoursite.com/2019/05/17/Algorithm0517/","excerpt":"","text":"难题1、P1868 饥饿的奶牛R:如果f[i]从f[j] (jf[i]具有单调性，那么二分查找可以降低复杂度。其次，遇到区间问题时，按某个端点排序可以有利于问题解决。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include using namespace std;const int maxn = 150000 + 10;/** * 首先将节点按照右端点排序，f[i]表示前i堆草的最大值，f[i] = max(f[i-1],f[j]+吃这堆草) * 排序以及该转移方程可以保证f是不减的,因为即使两个区间a,b的右端点相同，左端点不同，那它们位置上 * 是连续的，可以通过max这个转移过来。*/int N, f[maxn];struct Node { int l, r;} nodes[maxn];bool inline cmp(const Node& a, const Node& b) { return a.r < b.r; }inline int find(int x){ int l = 1, r = x, pos = 0; while (l > 1; if (nodes[mid].r < nodes[x].l) { pos = mid, l = mid + 1; } else { r = mid - 1; } } return pos;}int main(){ scanf(\"%d\", &N); for (int i = 1; i = nodes[i].num) { break; } if (!visited[j]) { k++, ans++, visited[j] = 1; } } } printf(\"%d\\n\", ans); system(\"pause\"); return 0;} 3、P4019 多边形染色R:环形dp的方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include using namespace std;/*** * 通过这道题，我学习了环状dp的方法：枚举开头，在最后一个判断合法性。 * dp[i][c] = sum(dp[i-1][k]) **/const int maxn = 50000 + 10, mod = 987654321;//col表示节点不能涂的颜色int N, M, C, dp[maxn][15], uncol[maxn][15], e[maxn];int main(){ int ans = 0; scanf(\"%d %d %d\", &N, &M, &C); for (int i = 1; i a[i]; sum[i] = sum[i - 1] + t[i]; total_a[i] = total_a[i - 1] + a[i]; } memset(f, 0x3f, sizeof(f)); f[0][0] = 0; for (int i = 1; i N >> S; for (int i = 1; i > t[i] >> a[i]; ts[i] = ts[i - 1] + t[i], as[i] = as[i - 1] + a[i]; } memset(f, 0x3f, sizeof(f)); f[0] = 0; for (ri i = 1; i > K; for (int i = 1; i > score[i]; sum[i] = sum[i - 1] + score[i]; } memset(dp, ~0x3f, sizeof(dp)); for (int i = 0; i","categories":[{"name":"Konjak Records","slug":"Konjak-Records","permalink":"http://yoursite.com/categories/Konjak-Records/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"},{"name":"迪杰斯特拉算法","slug":"迪杰斯特拉算法","permalink":"http://yoursite.com/tags/迪杰斯特拉算法/"}]},{"title":"Java程序提交Spark任务","slug":"Java0516","date":"2019-05-16T08:52:06.035Z","updated":"2019-05-18T08:14:32.091Z","comments":true,"path":"2019/05/16/Java0516/","link":"","permalink":"http://yoursite.com/2019/05/16/Java0516/","excerpt":"","text":"方法一1、java -cp *.jar xxx报错：java.lang.SecurityException: Invalid signature file digest for Manifest main attributes. 解决方法：打开META-INF目录，将.SF,.DSA,*.RSA文件删除即可。 Java程序调用Spark Submit1、首先引入maven依赖,需要注意的是将Spark中的hadoop去掉，然后引入自定义的hadoop版本。这个过程要对jar包进行更改,将maven reposity中的hadoop-common包中的core-default.xml添加以下语句,如果没有这个操作，可能会造成hdfs schema错误。参考链接 1234567891011 fs.hdfs.impl org.apache.hadoop.hdfs.DistributedFileSystem The FileSystem for hdfs: uris. fs.file.impl org.apache.hadoop.fs.LocalFileSystem The FileSystem for hdfs: uris. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 4.0.0 org.gzp.team submit 1.0 2.3.2 2.11 2.7.7 UTF-8 org.apache.spark spark-core_${scala.compat.version} ${spark.version} org.apache.hadoop * org.apache.hadoop hadoop-client ${org.apache.hadoop.version} org.apache.spark spark-sql_${scala.compat.version} ${spark.version} org.apache.maven.plugins maven-shade-plugin 3.1.0 package shade 2、调用SparkSubmit.main(args) 12345678import org.apache.spark.deploy.SparkSubmit;public class KFSubmit { public static void main(String[] args) { SparkSubmit.main(args); }} 3、调用java，注意里面有坑，需要提供两个虚拟机参数，否则会提交失败。 1java -Xms256m -Xmx1024m -cp submit-1.0.jar KFSubmit --class RipleysKJavaExample --conf \"spark.executor.memory=1g\" --conf \"spark.driver.memory=1g\" --master spark://master:7077 hdfs://master:9000/applications/origin_k.jar spark://master:7077 hdfs://master:9000/points/hubei.csv hdfs://master:9000/polygons/hubei.json true 10000 10000 10 Months 10 10 randomPermutation 1 70 true false false true hdfs://master:9000/ripleysk/try.json 4、很重要的一点，二者的spark版本要一致！！！！否者会可能会出现提交但是不工作的问题。 5、还有一个坑：写文件到hdfs时出现以下错误:java.lang.IllegalArgumentException: Wrong FS://expected: file:///解决方法是: 123Configuration conf = new Configuration();//使用hadoop的core-site.xml中的fs.defaultFS参数，防止Wrong FS: hdfs:.......file:/// 错误异常conf.set(\"fs.defaultFS\", \"hdfs://192.168.184.99:9000\"); 方法二1、引入Maven依赖12345 com.github.ywilkof spark-jobs-rest-client 1.3.9 2、向spark的Restful接口提交任务12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public String submitByRest(HttpServletRequest httpServletRequest) { //HttpServletRequest用来读取请求参数 SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd-HH-mm-ss\");//设置日期格式 String cur = df.format(new Date()); //masterHost指定spark://master:7077中的IP SparkRestClient sparkRestClient = SparkRestClient.builder() .masterHost(masterHost) .sparkVersion(sparkVersion) .build(); try { //程序需要用到的参数 String[] schemas = { master, \"hdfs://192.168.200.149:9000/points/hubei.csv\" , \"hdfs://192.168.200.149:9000/polygons/hubei.json\", \"true\", \"5000\", \"100\", \"10\", \"Months\", \"10\", \"10\", \"randomPermutation\", \"1\", \"70\", \"true\", \"false\", \"false\", \"true\", defaultDFS, resultDir + cur + \".json\"}; List arg = Arrays.asList(schemas); final String submissionId = sparkRestClient.prepareJobSubmit() .appName(appName) .appResource(appResource) .mainClass(mainClass) .appArgs(arg) .withProperties() .submit(); //put方法将内存等信息上传 /* .put(\"spark.executor.memory\", \"1g\") .put(\"spark.executor.cores\", \"8\") .put(\"spark.executor.nums\", \"50\") */ System.out.println(submissionId); while (true) { //查询状态 final DriverState driverState = sparkRestClient .checkJobStatus() .withSubmissionId(submissionId); System.out.println(driverState); if (driverState.name().equals(DriverState.RUNNING.name())) { continue; }else{ break; } } Thread.sleep(30000); return getResult(resultDir + cur + \".json\"); } catch (FailedSparkRequestException e) { e.printStackTrace(); return \"error\"; } catch (InterruptedException e) { e.printStackTrace(); return \"error\"; }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"},{"name":"Spark","slug":"Java/Spark","permalink":"http://yoursite.com/categories/Java/Spark/"}],"tags":[]},{"title":"Konjak Record——2019.05.15","slug":"Algorithm0515","date":"2019-05-15T08:07:31.550Z","updated":"2019-05-15T08:14:13.362Z","comments":true,"path":"2019/05/15/Algorithm0515/","link":"","permalink":"http://yoursite.com/2019/05/15/Algorithm0515/","excerpt":"","text":"难题1、P3004 [USACO10DEC]宝箱Treasure Chest123456789101112131415161718192021222324252627282930313233343536373839404142434445#include using namespace std;/** * f[i][j]表示区间[i,j]内先手所取的最大值 * f[i][j] = sum[i,j] - min(f[i+1][j],f[i][j-1]) * 内存限制64MB搞我用动态内存,压维我不太会 */const int maxn = 5000 + 10;int v[maxn], N, sum[maxn];int main(){ cin >> N; for (int i = 1; i > v[i]; sum[i] = sum[i - 1] + v[i]; } int** f = new int*[maxn]; int maxlen = N + 10; //f[1][0]表示f[1][1],f[2][0]表示f[2][2] for (int i = 1; i","categories":[{"name":"Konjak Records","slug":"Konjak-Records","permalink":"http://yoursite.com/categories/Konjak-Records/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"},{"name":"迪杰斯特拉算法","slug":"迪杰斯特拉算法","permalink":"http://yoursite.com/tags/迪杰斯特拉算法/"}]},{"title":"Konjak Record——2019.05.14","slug":"Algorithm0514","date":"2019-05-14T06:22:19.341Z","updated":"2019-05-15T08:08:17.116Z","comments":true,"path":"2019/05/14/Algorithm0514/","link":"","permalink":"http://yoursite.com/2019/05/14/Algorithm0514/","excerpt":"","text":"难题1、P4060 [Code+#1]可做题R:拆位dp、位运算、路径压缩 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include using namespace std;/*n nodes[i].k[j]; } cin >> nodes[i].price; } cin >> N; for (int i = 1; i > c >> k >> p; origin[c] = p, num[c] = k, kind[i] = c; } memset(dp, 0x3f, sizeof(dp)), dp[0][0][0][0][0] = 0; for (int i = 0; i w; if (l == 1) { if (s) { cout { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Konjak Records","slug":"Konjak-Records","permalink":"http://yoursite.com/categories/Konjak-Records/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"拆位dp","slug":"拆位dp","permalink":"http://yoursite.com/tags/拆位dp/"},{"name":"位运算","slug":"位运算","permalink":"http://yoursite.com/tags/位运算/"},{"name":"路径压缩","slug":"路径压缩","permalink":"http://yoursite.com/tags/路径压缩/"},{"name":"负值背包","slug":"负值背包","permalink":"http://yoursite.com/tags/负值背包/"},{"name":"多维完全背包","slug":"多维完全背包","permalink":"http://yoursite.com/tags/多维完全背包/"},{"name":"网格dp","slug":"网格dp","permalink":"http://yoursite.com/tags/网格dp/"},{"name":"快速幂","slug":"快速幂","permalink":"http://yoursite.com/tags/快速幂/"}]},{"title":"svn服务器搭建记录","slug":"svn","date":"2019-05-12T03:30:25.144Z","updated":"2019-05-12T03:48:26.517Z","comments":true,"path":"2019/05/12/svn/","link":"","permalink":"http://yoursite.com/2019/05/12/svn/","excerpt":"","text":"1、安装svn1sudo apt-get install subversion 2、创建目录1234567# 以下代码表示创建一个名为svn的根目录，GeoCommerce为具体项目名称。cd /home/hjw/modules/mkdir svncd svnmkdir GeoCommercechmod -R 777 /home/hjw/modules/svn/ 3、创建版本仓库1sudo svnadmin create /home/hjw/modules/svn/GeoCommerce 4、配置（1）svnserve.conf123456789[general]# 匿名用户不可读anon-access = none# 权限用户可写auth-access = write# 密码文件为passwdpassword-db = passwd# 权限文件为authzauthz-db = authz （2）authz123456[groups]# 用户组admin=wjh,syz,mzp,pdh[/] # 必须写/，因为这表示从仓库的目录开始设置权限@admin=rw # admin组有rw(读写权限)，所有人有r(读权限)*=r （3）passwd123456# 指定密码[users]wjh=foolmzp=godsyz=godpdh=god 5、启动svn服务1234sudo svnserve -d -r /home/hjw/modules/svn/ --listen-port 8888 # 启动服务器-d 守护模式-r 指定svn版本库根目录--listen-port 指定端口 6、连接svn打开svn客户端，输入svn://ip:port/GeoCommerce document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/其他/"}],"tags":[]},{"title":"Konjak Record——2019.05.11","slug":"Algorithm0511","date":"2019-05-11T06:45:56.938Z","updated":"2019-05-11T06:59:36.812Z","comments":true,"path":"2019/05/11/Algorithm0511/","link":"","permalink":"http://yoursite.com/2019/05/11/Algorithm0511/","excerpt":"","text":"素数打表1、P1832 A+B Problem（再升级）R:这是一个完全背包问题，对我来说这题还是挺难的，在大神眼里我就是个垃圾。注意代码中的质数打表方法，挺有用的(古人云:暴力出奇迹，打表出省一，爆搜挂着机，骗分过样例)。 12345678910111213141516171819202122232425262728293031323334353637383940#include using namespace std;const int maxn = 1000 + 10;int visited[maxn], primes[maxn], len, N;long long dp[maxn];void get_primes(){ for (int i = 2; i < maxn; i++) { if (!visited[i]) { primes[len++] = i; for (int j = i * i; j < maxn; j += i) { visited[j] = true; } } }}inline int cnt(){ for (int i = 0; i < len; i++) { if (primes[i] > N) { return i - 1; } } return 0;}int main(){ cin >> N; get_primes(); int num = cnt(); dp[0] = 1; for (int i = 0; i =1的区别！对于每次询问，我们先假设答案为f[s]，但s>=(d[1]+1)*c[1]，即f[s]中包含了第一种硬币超过限制的情况。要减去这部分。 很明显，对于第一种硬币超过限制的情况，所用的第一种硬币数量>=d[1]+1。 容易发现，总和为s，第一种硬币至少d[1]+1的情况个数，等于总和为s-(d[1]+1)*c[1]，硬币个数没有限制的情况个数！ 因为总和为s，第一种硬币至少d[1]+1的情况个数中，那d[1]+1个硬币是固定的，是不会变的，对于情况个数是不会有影响的。 所以，我们将原先为f[s]的答案减去f[s-(d[1]+1)*c[1]]即可得出正确答案。 这只是一种硬币超过限制的解决办法。对于两种硬币超过限制我们也同样这么减去，但重复减去了一部分：那些两种硬币同时超过限制的情况。 因此我们要加回两种硬币同时超过限制的情况接着用位运算计算容斥原理的结果。*/int main(){ for (int i = 1; i { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Konjak Records","slug":"Konjak-Records","permalink":"http://yoursite.com/categories/Konjak-Records/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"},{"name":"质数打表","slug":"质数打表","permalink":"http://yoursite.com/tags/质数打表/"},{"name":"容斥原理","slug":"容斥原理","permalink":"http://yoursite.com/tags/容斥原理/"}]},{"title":"Konjak Record——2019.05.10","slug":"Algorithm0510","date":"2019-05-10T08:02:01.922Z","updated":"2019-05-11T06:45:24.366Z","comments":true,"path":"2019/05/10/Algorithm0510/","link":"","permalink":"http://yoursite.com/2019/05/10/Algorithm0510/","excerpt":"","text":"常规题1、P1336 最佳课题选择R:多重背包 123456789101112131415161718192021222324252627282930#include using namespace std;const int maxn = 205;struct Node { int A, B;} nodes[25];int N, M;long long dp[25][maxn];int main(){ cin >> N >> M; for (int i = 1; i > nodes[i].A >> nodes[i].B; } memset(dp, 0x3f, sizeof(dp)); //前i个课题选0篇的时间均为0 for (int i = 0; i people[i] >> l >> r; if (l != 0) add_edge(i, l), add_edge(l, i); if (r != 0) add_edge(i, r), add_edge(r, i); } for (int i = 1; i v; if (v == f) { continue; } sum = (w[v] + sum) % mod; sq = (w[v] * w[v] + sq) % mod; //求第一第二的权值 if (w[v] >= first) { second = first, first = w[v]; } else { if (w[v] > second) { second = w[v]; } } dfs(v, s, f); } //注意这里负数的解决方法 total_sum = ((sum * sum - sq + mod) % mod + total_sum) % mod; mx = max(mx, first * second); total_sum = (2 * w[s] * w[g] + total_sum) % mod; mx = max(w[s] * w[g], mx);}int main(){ ios::sync_with_stdio(0), cin.tie(0); cin >> N; for (int i = 1; i < N; i++) { int u, v; cin >> u >> v; add_edge(u, v), add_edge(v, u); } for (int i = 1; i > w[i]; } dfs(1, 0, 0); cout","categories":[{"name":"Konjak Records","slug":"Konjak-Records","permalink":"http://yoursite.com/categories/Konjak-Records/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"LCS->LIS","slug":"LCS-LIS","permalink":"http://yoursite.com/tags/LCS-LIS/"},{"name":"单调队列","slug":"单调队列","permalink":"http://yoursite.com/tags/单调队列/"}]},{"title":"Konjak Record——2019.05.09","slug":"Algorithm0509","date":"2019-05-09T13:39:58.443Z","updated":"2019-05-09T14:34:06.690Z","comments":true,"path":"2019/05/09/Algorithm0509/","link":"","permalink":"http://yoursite.com/2019/05/09/Algorithm0509/","excerpt":"","text":"常规题1、P1279 字串距离R:最大公共子序列的变形。 123456789101112131415161718192021222324252627282930#include using namespace std;char a[2005], b[2005];int d, dp[2005][2005], alen, blen;inline int Min(int n1, int n2){ return n1 > n2 ? n2 : n1;}inline int Abs(int n1, int n2){ return n1 > n2 ? n1 - n2 : n2 - n1;}int main(){ scanf(\"%s\", &a[1]), scanf(\"%s\", &b[1]), scanf(\"%d\", &d), alen = strlen(a + 1), blen = strlen(b + 1); for (int i = 1; i N >> K; for (int i = 1; i > f[i]; sum[i] = sum[i - 1] + f[i]; } memset(dp, 0x3f, sizeof(dp)); dp[0][0] = 0; for (int i = 1; i","categories":[{"name":"Konjak Records","slug":"Konjak-Records","permalink":"http://yoursite.com/categories/Konjak-Records/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"区间dp","slug":"区间dp","permalink":"http://yoursite.com/tags/区间dp/"},{"name":"表达式转换","slug":"表达式转换","permalink":"http://yoursite.com/tags/表达式转换/"},{"name":"状压dp","slug":"状压dp","permalink":"http://yoursite.com/tags/状压dp/"}]},{"title":"Konjak Record——2019.05.07","slug":"Algorithm0507","date":"2019-05-07T10:17:57.142Z","updated":"2019-05-09T13:39:42.212Z","comments":true,"path":"2019/05/07/Algorithm0507/","link":"","permalink":"http://yoursite.com/2019/05/07/Algorithm0507/","excerpt":"","text":"常规题1、P1216 [IOI1994][USACO1.5]数字三角形 Number TrianglesR:水题 12345678910111213141516171819202122232425262728#include using namespace std;const int maxn = 1005;int f[maxn][maxn], dp[maxn][maxn], N;int main(){ ios::sync_with_stdio(false); cin.tie(0); cin >> N; for (int i = 1; i f[i][j]; } if (i == N) { for (int j = 1; j = 1; i--) { for (int j = 1; j > M; for (int i = 1; i f[i][j]; L[i][j] = R[i][j] = j; up[i][j] = 1; } } //预处理L for (int i = 1; i a[i].s >> a[i].w >> a[i].fa, id[a[i].s] = i; for (int i = 1; i v; int t = dfs(v); sum += t; for (int i = sum; i >= 0; i--) { for (int j = 1; j = j) { dp[x][i] = max(dp[x][i], dp[v][j] + dp[x][i - j] - p->len); } } } } return sum;}int main(){ ios::sync_with_stdio(false); cin.tie(0); cin >> N >> M; for (int i = 1; i > K; for (int j = 1; j > a >> c; add_edge(i, a, c); du[c]++; } } for (int i = N - M + 1; i > pay[i]; } dfs(1); for (int j = M; j >= 0; j--) { if (dp[1][j] >= 0) { cout { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Konjak Records","slug":"Konjak-Records","permalink":"http://yoursite.com/categories/Konjak-Records/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"树形dp","slug":"树形dp","permalink":"http://yoursite.com/tags/树形dp/"},{"name":"悬线法","slug":"悬线法","permalink":"http://yoursite.com/tags/悬线法/"},{"name":"Dilworth定理","slug":"Dilworth定理","permalink":"http://yoursite.com/tags/Dilworth定理/"}]},{"title":"Konjak Record——2019.05.06","slug":"Algorithm0506","date":"2019-05-06T10:32:45.766Z","updated":"2019-05-06T10:51:42.086Z","comments":true,"path":"2019/05/06/Algorithm0506/","link":"","permalink":"http://yoursite.com/2019/05/06/Algorithm0506/","excerpt":"","text":"常规题1、P1057 传球游戏R:水题，思路很好想。 123456789101112131415161718192021222324252627#include using namespace std;int dp[35][35], N, M;int main(){ cin >> N >> M; dp[1][0] = 1; for (int i = 1; i > M; for (int i = 1; i > f[i]; } dp[0] = 1; for (int i = 1; i = 0; j--) { for (int k = 1; k = 0; k++) { dp[j] = (dp[j - k] + dp[j]) % mod; } } } cout N; for (int i = 1; i > f[i]; } for (int i = 1; i > M; for (int i = 1; i chess[i][j]; } } for (int i = 1; i > K; for (int i = 1; i > nodes[i].h >> nodes[i].w; } sort(nodes + 1, nodes + 1 + N, cmp); memset(dp, 0x3f, sizeof(dp)); dp[0][0] = 0; for (int i = 1; i j - (i - k - 1) && j - (i - k - 1) >= 0) { dp[i][j] = Min(dp[i][j], dp[k][j - (i - k - 1)] + Abs(nodes[i].w - nodes[k].w)); } } } } for (int i = 1; i = 0) { ans = min(dp[i][K - (N - i)], ans); } } cout N; for (int i = 1; i > f[i]; } //O(N^2)，N小于等于5000没问题 for (int i = 1; i","categories":[{"name":"Konjak Records","slug":"Konjak-Records","permalink":"http://yoursite.com/categories/Konjak-Records/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}]},{"title":"Konjak Record——2019.05.02","slug":"Algorithm0502","date":"2019-05-02T04:01:40.078Z","updated":"2019-05-02T13:12:31.019Z","comments":true,"path":"2019/05/02/Algorithm0502/","link":"","permalink":"http://yoursite.com/2019/05/02/Algorithm0502/","excerpt":"","text":"模板题P3834 【模板】可持久化线段树 1（主席树）R:求区间第k大，主席树方法，注意离散化的方法，以及二分查找。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include using namespace std;const int maxn = 2e5 + 10;int root[maxn], N, Q, f[maxn], cnt;struct Node { int l, r, sum;};Node T[maxn * 40];vector v;inline int getid(int x){ return lower_bound(v.begin(), v.end(), x) - v.begin() + 1;}inline int read(){ int f = 1, r = 0; char c = getchar(); while (!isdigit(c)) { if (c == '-') f = -1; c = getchar(); } while (isdigit(c)) { r = 10 * r + c - '0'; c = getchar(); } return f * r;}void update(int pos, int l, int r, int& x, int y){ T[++cnt] = T[y], x = cnt; T[cnt].sum += 1; if (l == r) { return; } int mid = (l + r) >> 1; if (pos > 1; if (sum >= k) { return query(l, mid, T[x].l, T[y].l, k); } else { return query(mid + 1, r, T[x].r, T[y].r, k - sum); }}int main(){ N = read(), Q = read(); for (int i = 1; i > k; update(x, y, 1, N, k, 1); } else { long long q = query(x, y, 1, N, 1); cout T[x].v; return; } int mid = (l + r) >> 1; build(l, mid, T[x].l); build(mid + 1, r, T[x].r);}void update(int pos, int v, int l, int r, int& x, int y){ T[++cnt] = T[y], x = cnt; if (l == r) { T[x].v = v; return; } int mid = (l + r) >> 1; if (pos > 1; if (pos > N >> M; build(1, N, root[0]); for (int i = 1; i > v >> w >> loc; if (w == 1) { cin >> u; update(loc, u, 1, N, root[i], root[v]); } else { root[i] = root[v]; int q = query(loc, 1, N, root[i]); cout = L && r > 1; int mn = 0x3f3f3f3f; if (mid >= L) { mn = min(query(L, R, l, mid, T[cur].l), mn); } if (mid < R) { mn = min(query(L, R, mid + 1, r, T[cur].r), mn); } return mn;}int main(){ scanf(\"%d %d\", &N, &M); build(1, N, root); for (int i = 1; i { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Konjak Records","slug":"Konjak-Records","permalink":"http://yoursite.com/categories/Konjak-Records/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/线段树/"},{"name":"主席树","slug":"主席树","permalink":"http://yoursite.com/tags/主席树/"}]},{"title":"Konjak Record——2019.05.01","slug":"Algorithm0501","date":"2019-05-01T02:52:51.729Z","updated":"2019-05-01T11:13:20.105Z","comments":true,"path":"2019/05/01/Algorithm0501/","link":"","permalink":"http://yoursite.com/2019/05/01/Algorithm0501/","excerpt":"常规题1、P1177 【模板】快速排序分析：要求写快速排序，我很懒，就直接调用了sort函数(其实是不会)。 12345678910111213141516#include using namespace std;const int maxn = 100000+10;int f[maxn],N;int main(){ scanf(\"%d\",&N); for(int i = 1 ; i","text":"常规题1、P1177 【模板】快速排序分析：要求写快速排序，我很懒，就直接调用了sort函数(其实是不会)。 12345678910111213141516#include using namespace std;const int maxn = 100000+10;int f[maxn],N;int main(){ scanf(\"%d\",&N); for(int i = 1 ; i K; for(int i = 1 ; i >E[i]; } for(int i = 1 ; i>nodes[i].w; nodes[i].id=i; } sort(nodes+1,nodes+1+N,cmp); for(int i = 1 ; i >shitLeader>>w>>shitSci; int tmp = 0; if(self>80&&shitSci>=1){ tmp+=8000; } if(self>85&&shits>80){ tmp+=4000; } if(self>90){ tmp+=2000; } if(w=='Y'&&self>85){ tmp+=1000; } if(shitLeader=='Y'&&shits > 80){ tmp+=850; } if(tmp>sm){ sm=tmp,mx=name; } total += tmp; } cout","categories":[{"name":"Konjak Records","slug":"Konjak-Records","permalink":"http://yoursite.com/categories/Konjak-Records/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"}]},{"title":"Konjak Record——2019.04.30","slug":"Algorithm0430","date":"2019-04-30T06:29:16.296Z","updated":"2019-04-30T12:52:19.220Z","comments":true,"path":"2019/04/30/Algorithm0430/","link":"","permalink":"http://yoursite.com/2019/04/30/Algorithm0430/","excerpt":"常规题1、P1855 榨取kkksc03分析：01背包的变形，多加一个维度就可以了 123456789101112131415161718192021#include using namespace std;const int maxn = 105, maxm = 205;int dp[maxm][maxm], m[maxm], t[maxm], N, M, T;int main(){ scanf(\"%d %d %d\", &N, &M, &T); for (int i = 1; i = t[i]; k--) { dp[j][k] = max(dp[j][k], dp[j - m[i]][k - t[i]] + 1); } } } printf(\"%d\\n\", dp[M][T]); system(\"pause\"); return 0;}","text":"常规题1、P1855 榨取kkksc03分析：01背包的变形，多加一个维度就可以了 123456789101112131415161718192021#include using namespace std;const int maxn = 105, maxm = 205;int dp[maxm][maxm], m[maxm], t[maxm], N, M, T;int main(){ scanf(\"%d %d %d\", &N, &M, &T); for (int i = 1; i = t[i]; k--) { dp[j][k] = max(dp[j][k], dp[j - m[i]][k - t[i]] + 1); } } } printf(\"%d\\n\", dp[M][T]); system(\"pause\"); return 0;} 错题2、P1736 创意吃鱼法分析：这个题调试了一个下午才AC，还是太菜了。使用的是悬线法,注意对角线共两个方向，此外必须保证除了对角线为1以外其他都为0。具体细节见代码。代码跑的很慢，复杂度是O(N2),而且我是大常数男人。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include using namespace std;const int maxn = 2505;int N, M;short chess[maxn][maxn], l[maxn][maxn], L[maxn][maxn];short r[maxn][maxn], R[maxn][maxn], u[maxn][maxn], U[maxn][maxn], f[maxn][maxn], ans;int main(){ scanf(\"%d %d\", &N, &M); memset(chess, -1, sizeof(chess)); for (int i = 1; i chess[i][j]; l[i][j] = j, r[i][j] = j, u[i][j] = i; L[i][j] = R[i][j] = j, U[i][j] = i; } } for (int i = 1; i > G; for (int i = 1; i > nodes[i].t >> nodes[i].f >> nodes[i].h; } sort(nodes + 1, nodes + 1 + G, cmp); memset(dp, -1, sizeof(dp)); dp[0][0] = 10; for (int i = 1; i = D) { printf(\"%d\\n\", nodes[i].t); system(\"pause\"); return 0; } if (dp[i - 1][j] >= pay) { dp[i][j] = dp[i - 1][j] - pay + nodes[i].f; } if (j >= nodes[i].h && dp[i - 1][j - nodes[i].h] >= pay) { dp[i][j] = max(dp[i][j], dp[i - 1][j - nodes[i].h] - pay); } } } int maxt = 0; for (int i = 0; i { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Konjak Records","slug":"Konjak-Records","permalink":"http://yoursite.com/categories/Konjak-Records/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}]},{"title":"Konjak Record——2019.04.29","slug":"Algorithm0429","date":"2019-04-29T06:38:36.135Z","updated":"2019-04-29T11:27:18.615Z","comments":true,"path":"2019/04/29/Algorithm0429/","link":"","permalink":"http://yoursite.com/2019/04/29/Algorithm0429/","excerpt":"常规题1、P1140 相似基因分析：LCS的变形，水题","text":"常规题1、P1140 相似基因分析：LCS的变形，水题 2、P1282 多米诺骨牌分析：背包的变形，记录上下差值为M时的最小翻转次数，因为有正负，所以多开一维表达正负数。 123sub = up[i] - down[i]dp[i][j] = min(dp[i - 1][j - sub],dp[i - 1][j + sub] + 1)-maxm < j < maxm,1 nodes[i].b; } for (int i = 1; i > nodes[i].t; } sort(nodes + 1, nodes + 1 + N, cmp); for (ll i = 1; i = nodes[i].t; j--) { dp[j] = max(dp[j - nodes[i].t] + nodes[i].a - nodes[i].b * j, dp[j]); } } long long ans = -1; for (ll i = 1; i { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Konjak Records","slug":"Konjak-Records","permalink":"http://yoursite.com/categories/Konjak-Records/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}]},{"title":"Chtholly Nota Seniorious","slug":"Chtholly Nota Seniorious","date":"2019-04-26T05:29:26.974Z","updated":"2019-04-26T07:21:56.264Z","comments":true,"path":"2019/04/26/Chtholly Nota Seniorious/","link":"","permalink":"http://yoursite.com/2019/04/26/Chtholly Nota Seniorious/","excerpt":"C++1cout","text":"C++1cout { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"科学","slug":"科学","permalink":"http://yoursite.com/categories/科学/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-04-25T03:08:59.435Z","updated":"2019-04-26T04:29:16.111Z","comments":true,"path":"2019/04/25/hello-world/","link":"","permalink":"http://yoursite.com/2019/04/25/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]}]}